import bilby
import numpy as np
from gwpy.timeseries import TimeSeries
import os
import random
import subprocess
import shutil

DURATION = 128


def get_gwosc_data(duration :int = DURATION, sample_rate: int = 16384):

    """
    Get LIGO data from GWOSC 

    number: number of strain dataset to fetch
    duration: length of signal segment (default = 128, optimal for omicron and PSD estimation)
    sample_rate: default = 16384, optimal for GravitySpy Q-scan generation

    merger_time is simply the centre of the signal segment, this data is raw and has no injections
    """

    #Specifying GPS time ranges for each observing run
    O1_range = [1126051217, 1137254417]
    O2_range = [1164556817, 1187733618]
    O3a_range = [1238166018, 1253977218]
    O3b_range = [1256655618, 1269363618]

    Obs_runs = [O1_range, O2_range, O3a_range, O3b_range]

    for attempt in range(10): #Try generated GPS time 10 times

        #Randomly select an observing run
        run_select = Obs_runs[random.randint(0,len(Obs_runs)-1)]

        print('Run Selection = {}'.format(run_select))

        #Randomly select a start time within that observing run, leaving room at the end for signal trail-off

        merger = random.randint(run_select[0], run_select[1]-duration)
        start = merger - duration/2
        end = start + duration

        try: #Attempt to locate GWOSC dataset 
            fetch_time_series = TimeSeries.fetch_open_data('H1', start, end, sample_rate = sample_rate, verbose = True)
        
        except: 
            print('Could not find dataset, retrying')

        else: #if successful, break

            time_series = fetch_time_series, int(start), int(end), merger
            break

    else:

        print('Could not find dataset after {} attempts'.format(attempt + 1))

    return time_series

def save_to_gwf(data, output_path: str, duration: int = DURATION, file_tag: str = 'SIM', signal_tag:str = 'CHIRP'):

    """
    Save GWOSC data to gwf, and set channel name (allows omicron to be ran on empty strain data)

    data[0] = timeseries
    data[1] = segment start time
    data[2] = segment end time
    data[3] = merger time
    """

    if not os.path.exists(output_path):
        os.mkdir(output_path)
        
    segment_start_time = data[1]

    # Naming gwf channel to the Omicron specification
    data[0].name = "H1:" + file_tag + "-" + signal_tag
    data[0].channel = "H1:" + file_tag + "-" + signal_tag

    # Writing injection as .gwf file
    data[0].write(output_path + '/H-H1_'+ file_tag +'-{0}-{1}.gwf'.format(segment_start_time, duration))

def generate_omicron_cache_files(data, data_absolute_path : str, output_path: str = os.getcwd(), duration:int = DURATION, file_tag:str = 'SIM'):

    """
    Generate a .lcf cache file for a given segment to run omicron 
    data: list [timeseries, start_time, end_time, merger_time]
    data_path: string of relative path to data, not including the datafile itself
    output_path: default is cwd
    file_tag: tags the file with relevant info (e.g RAW or STRAIN)
    """

    segment_start_time = data[1]
    cwd = os.getcwd()
    #Generating Cache file, points to the location of the injection

    omicron_cache_file = open(output_path + '/' + file_tag.lower()+ '.lcf', "w+")
    omicron_cache_file.write('file://localhost' + data_absolute_path + '/H-H1_'+ file_tag +'-{0}-{1}.gwf'.format(segment_start_time, duration))
    omicron_cache_file.close()

def pass_through_omicron(data):
    
    """
    Run omicron on a given set of data, returns a list of each terminal output message for each signal in the dataset

    injections: list of timeseries data with injected signal
    start_times: list of of the GPS start time for each timeseries data
    duration: duration of the timeseries
    
    """

    start_time = data[1]
    end_time = data[2]

    # Run injection through Omicron

    # Setting the terminal command to run omicron
    omicron_command = "omicron-process --gps {0} {1} --ifo H1 --config-file ./sim.ini --output-dir ./run --no-segdb --cache-file ./sim.lcf -vvv --file-tag SIM SIM --no-submit".format(start_time,end_time)

    # running pyomicron through terminal and printing the output
    run_pyomicron = subprocess.run(omicron_command.split(), shell=False, capture_output=True, text=True)
    print(run_pyomicron.stdout)

    # running omicron bash script generated by pyomicron 
    run_omicron_script = subprocess.run("./run/condor/omicron-SIM.sh", shell=True, capture_output=True, text=True)
    print(run_omicron_script.stdout)

    os.remove('sim.lcf')

    cwd = os.getcwd()

    # specifying the path of the omicron trigger files
    omicron_output_path = cwd + "/run/merge/H1:SIM-CHIRP/H1-SIM_CHIRP_OMICRON-{}-124.root".format(int(start_time+2)) #+2 as the chunk starts 2s later

    # printing the result of the trigger files
    omicron_output = subprocess.run(["omicron-print", "file={}".format(omicron_output_path)], shell=False, capture_output=True, text=True)

    return omicron_output

def parse_omicron_output(omicron_output):

    """
    Parsing the terminal output message from Omicron to be used in Python, returns a list of peak time, frequency, and SNR values for each signal
    """

    print(omicron_output.stdout)


    #Formatting the output readings

    output_split = omicron_output.stdout.split("\n")
    output_numbers = output_split[4:-1]

    #print(output_numbers)

    output_array = []
    for row in output_numbers:
        output_array.append(list(map(float, row.split())))

    #print(output_array)
    peak_times = []
    frequencies = []
    snrs = []

    for i, readings in enumerate(output_array):
        peak_time = output_array[i][0]
        frequency = output_array[i][1]
        snr = output_array[i][2]

        peak_times.append(peak_time)
        snrs.append(snr)
        frequencies.append(frequency)

    return peak_times, frequencies, snrs

def check_omicron_threshold_strain(data, snrs: list, signal_current_path:str, duration = DURATION):

    """
    Sorts the strain data into clean strain and contaminated strain

    snrs: list of snr values from omicron
    start_times: omicron start times
    signal_current_path: path to signal 

    """

    start_time = data[1]

    if snrs:

        print('max SNR for signal is {}'.format(max(snrs)))

        if max(snrs) > 7.5:
            print('peak SNR greater than 7.5, strain is contaminated')

            os.mkdir('./contaminated_strain')
            os.rename(signal_current_path + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration), './contaminated_strain' + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration))

        else:
            print('peak SNR greater than 7.5, strain is contaminated')

            os.mkdir('./contaminated_strain')
            os.rename(signal_current_path + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration), './contaminated_strain' + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration))

    else:
        print('No triggers detected, strain is clean') 

        os.mkdir('./clean_strain')
        os.rename(signal_current_path + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration), './clean_strain' + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration))
        
def check_omicron_threshold_injection(data, snrs, signal_current_path, duration = DURATION):

    """
    Moves successful injections into a /successful_injections folder and deletes the failed ones (minimum SNR of 7.5)

    snrs: list of snr values from omicron
    start_times: omicron start times
    injection_path: path to injections 

    """

    start_time = data[1]

    if snrs:

        print('max SNR for signal is {}'.format(max(snrs)))
    

        if max(snrs) > 7.5:
            print('peak SNR greater than 7.5, injection accepted')

            os.mkdir('./successful_injections')
            os.rename(signal_current_path + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration), './successsful_injections' + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration))

        else:
            print('SNR less than 7.5, removing injection')
            os.remove(signal_current_path + '/H-H1_SIM-{0}-{1}.gwf'.format(int(start_time), duration))

    else:

        print('No triggers detected for injenction')

time_series = get_gwosc_data()

save_to_gwf(data=time_series, output_path='./gwosc_data')

cwd = os.getcwd()

generate_omicron_cache_files(data=time_series, data_absolute_path= cwd + '/gwosc_data')

omicron_output = pass_through_omicron(data=time_series)

peak_times, frequencies, snrs = parse_omicron_output(omicron_output=omicron_output)

check_omicron_threshold_strain(data = time_series, snrs = snrs, signal_current_path='./gwosc_data')